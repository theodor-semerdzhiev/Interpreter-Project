
# Does a recursive DFS with memoization to find shortest path
func shortestpath(m) {
    let visited = [];
    for(let i =0; i < len(m); i = i + 1;) {
        let l = [];
        for(let j=0; j < len(m[i]); j = j + 1;) {
            l->append(0);
        }
        visited->append(l);
    }

    let mem = [];
    for(let i =0; i < len(m); i = i + 1;) {
        let l = [];
        for(let j=0; j < len(m[i]); j = j + 1;) {
            l->append(-1);
        }
        mem->append(l);
    }

    func sol(col, row) {
        if((col == -1) || (row == -1) || (col == len(m[0])) || (row == len(m))) {
            return 10000000000;
        }

        if(!(mem[row][col] == -1)) {
            return 1+mem[row][col];
        }
        

        if(visited[row][col] == 1) {
            return 10000000000;
        }


        if(m[row][col] == 1) {
            return 10000000000;
        }

        if((col == (len(m[row])-1)) && (row == (len(m)-1))) {
            return 0;
        }

        visited[row][col] = 1;

        let res = min(
            sol(col-1, row),
            sol(col+1, row),
            sol(col, row-1),
            sol(col, row+1)
        );

        visited[row][col] = 0;

        mem[row][col] = res;
        return 1+res;

    }

    return sol(0,0);
}

let w = [
    [0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000],
    [1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000],
    [1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000],
    [1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000],
    [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000],
    [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
    [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
    [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
    [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
];

let w1 = copy(w);


println(shortestpath(w));
println(shortestpath(w1));